//////////////////////////////////////////////////////////////////////
//
// G00616949
//
// Paul McKerley
//
// CS675 Spring 2020 -- Lab2
//
// Performs reduce actions for word count service.
//
//////////////////////////////////////////////////////////////////////

package main

import (
    "bytes"
    "cs675-spring20-labs/lab2/serverless"
    "encoding/gob"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "os"
    "sort"
    "strconv"
)

// To compile the map plugin: run:
// go build --buildmode=plugin -o wcr_service.so wcr_service.go

// Define Word Count's reduce service
type wcrService string

// MapReduceArgs defines this plugin's argument format
type MapReduceArgs struct {
    JobName string
    InFile  string
    TaskNum int
    NReduce int
    NOthers int
}

type KeyValue struct {
    Key   string
    Value string
}

func checkError(err error) {
    if err != nil {
        log.Fatal(err)
    }
}

const debugEnabled = true

func Debug(format string, a ...interface{}) (n int, err error) {
    if debugEnabled {
        n, err = fmt.Printf(format, a...)
    }
    return
}

// The reduce function is called once for each key generated by Map,
// with a list of that key's string value (merged across all inputs).
// The return value should be a single output value for that key.
func reduceF(key string, values []string) string {
    accumulator := 0
    for _, v := range values {
        i, err := strconv.Atoi(v)
        checkError(err)
        accumulator += i
    }
    return strconv.Itoa(accumulator)
}

// doReduce does the job of a reduce worker: it reads the
// intermediate key/value pairs (produced by the map phase) for this
// task, sorts the intermediate key/value pairs by key, calls the
// user-defined reduce function (reduceF) for each key, and writes
// the output to disk. Each reduce generates an output file named
// using serverless.MergeName(jobName, reduceTask).
func doReduce(
    jobName string,
    reduceTaskNum int,
    nMap int,
) {
    inputs := make([]*KeyValue, 0)
    for i := 0; i < nMap; i++ {
        fileName := serverless.ReduceName(jobName, i, reduceTaskNum)
        f, err := os.Open(fileName)
        checkError(err)
        defer f.Close()
        dec := json.NewDecoder(f)

        for {
            kv := new(KeyValue)
            if err := dec.Decode(&kv); err == io.EOF {
                break
            }
            checkError(err)
            inputs = append(inputs, kv)
        }
    }
    sort.Slice(inputs, func(i, j int) bool { return inputs[i].Key < inputs[j].Key })

    fileName := serverless.MergeName(jobName, reduceTaskNum)
    Debug("Creating %s\n", fileName)
    f, err := os.Create(fileName)
    checkError(err)
    defer f.Close()
    enc := json.NewEncoder(f)

    doReduce := func(enc *json.Encoder, k string, v []string) {
        output := reduceF(k, v)
        new_kv := new(KeyValue)
        new_kv.Key = k
        new_kv.Value = output
        err = enc.Encode(&new_kv)
        checkError(err)
    }

    var lastKey string
    values := make([]string, 0)
    for i, kv := range inputs {
        if kv.Key != lastKey && i > 0 {
            doReduce(enc, lastKey, values)
            values = make([]string, 0)
        }
        lastKey = kv.Key
        values = append(values, kv.Value)
    }
    doReduce(enc, lastKey, values)
}

// DON'T MODIFY THIS FUNCTION
func (s wcrService) DoService(raw []byte) error {
    var args MapReduceArgs
    buf := bytes.NewBuffer(raw)
    dec := gob.NewDecoder(buf)
    err := dec.Decode(&args)
    if err != nil {
        fmt.Printf("Word Count Service: Failed to decode!\n")
        return err
    }
    fmt.Printf("Hello from wordCountService plugin: %s\n", args.InFile)

    doReduce(args.JobName, args.TaskNum, args.NOthers)

    return nil
}

var Interface wcrService
