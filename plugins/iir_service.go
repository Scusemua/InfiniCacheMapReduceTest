//////////////////////////////////////////////////////////////////////
//
// G00616949
//
// Paul McKerley
//
// CS675 Spring 2020 -- Lab2
//
// Performs reduce actions for inverted index service.
//
//////////////////////////////////////////////////////////////////////

package main

import (
	"bytes"
	"github.com/Scusemua/InfiniCacheMapReduceTest/serverless"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strings"
)

// To compile the map plugin: run:
// go build --buildmode=plugin -o iir_service.so iir_service.go

// Define Inverted Indexing's reduce service
type iirService string

// MapReduceArgs defines this plugin's argument format
//type MapReduceArgs struct {
	// 	JobName       string
	// 	S3Key         string
	// 	TaskNum       int
	// 	NReduce       int
	// 	NOthers       int
	// 	SampleKeys    []string
	// 	StorageIPs    []string
	// 	DataShards    int
	// 	ParityShards  int
	// 	MaxGoroutines int
	// 	Pattern 	  string 
	// }

type KeyValue struct {
	Key   string
	Value string
}

func checkError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

const debugEnabled = true

func Debug(format string, a ...interface{}) (n int, err error) {
	if debugEnabled {
		n, err = fmt.Printf(format, a...)
	}
	return
}

// The reduce function is called once for each key generated by Map,
// with a list of that key's string value (merged across all inputs).
// The return value should be a single output value for that key.
func reduceF(key string, values []string) string {
	// Just sort and count the documents. Output as value.
	sort.Slice(values, func(i, j int) bool { return values[i] < values[j] })
	return fmt.Sprintf("%d %s", len(values), strings.Join(values, ","))
}

// doReduce does the job of a reduce worker: it reads the
// intermediate key/value pairs (produced by the map phase) for this
// task, sorts the intermediate key/value pairs by key, calls the
// user-defined reduce function (reduceF) for each key, and writes
// the output to disk. Each reduce generates an output file named
// using serverless.MergeName(jobName, reduceTask).
func doReduce(
	jobName string,
	reduceTaskNum int,
	nMap int,
) {
	inputs := make([]*KeyValue, 0)
	for i := 0; i < nMap; i++ {
		fileName := serverless.ReduceName(jobName, i, reduceTaskNum)
		f, err := os.Open(fileName)
		checkError(err)
		defer f.Close()
		dec := json.NewDecoder(f)

		for {
			kv := new(KeyValue)
			if err := dec.Decode(&kv); err == io.EOF {
				break
			}
			checkError(err)
			inputs = append(inputs, kv)
		}
	}
	sort.Slice(inputs, func(i, j int) bool { return inputs[i].Key < inputs[j].Key })

	fileName := serverless.MergeName(jobName, reduceTaskNum)
	Debug("Creating %s\n", fileName)
	f, err := os.Create(fileName)
	checkError(err)
	defer f.Close()
	enc := json.NewEncoder(f)

	doReduce := func(enc *json.Encoder, k string, v []string) {
		output := reduceF(k, v)
		new_kv := new(KeyValue)
		new_kv.Key = k
		new_kv.Value = output
		err = enc.Encode(&new_kv)
		checkError(err)
	}

	var lastKey string
	values := make([]string, 0)
	for i, kv := range inputs {
		if kv.Key != lastKey && i > 0 {
			doReduce(enc, lastKey, values)
			values = make([]string, 0)
		}
		lastKey = kv.Key
		values = append(values, kv.Value)
	}
	doReduce(enc, lastKey, values)
}

// DON'T MODIFY THIS FUNCTION
func (s iirService) DoService(raw []byte) error {
	var args serverless.MapReduceArgs
	buf := bytes.NewBuffer(raw)
	dec := gob.NewDecoder(buf)
	err := dec.Decode(&args)
	if err != nil {
		fmt.Printf("Inverted Indexing Service: Failed to decode!\n")
		return err
	}
	fmt.Printf("Hello from inverted indexing service plugin: %s\n", args.S3Key)

	doReduce(args.JobName, args.TaskNum, args.NOthers)

	return nil
}

var Interface iirService
